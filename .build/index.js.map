{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["// Welcome to\n// __________         __    __  .__                               __\n// \\______   \\_____ _/  |__/  |_|  |   ____   ______ ____ _____  |  | __ ____\n//  |    |  _/\\__  \\\\   __\\   __\\  | _/ __ \\ /  ___//    \\\\__  \\ |  |/ // __ \\\n//  |    |   \\ / __ \\|  |  |  | |  |_\\  ___/ \\___ \\|   |  \\/ __ \\|    <\\  ___/\n//  |________/(______/__|  |__| |____/\\_____>______>___|__(______/__|__\\\\_____>\n//\n// This file can be a nice home for your Battlesnake logic and helper functions.\n//\n// To get you started we've included code to prevent your Battlesnake from moving backwards.\n// For more info see docs.battlesnake.com\n\n// info is called when you create your Battlesnake on play.battlesnake.com\n// and controls your Battlesnake's appearance\n// TIP: If you open your Battlesnake URL in a browser you should see this data\n\nimport runServer from './server';\nimport { GameState, InfoResponse, MoveResponse, Coord, CoordNode, Board, Battlesnake } from './types';\nimport { AStarFinder } from \"astar-typescript\";\n\nfunction createArrayRepresentation(gameState: GameState): number[][] {\n  let array: number[][] = [];\n  const width = gameState.board.width - 1; //10\n  const height = gameState.board.height - 1; //10\n  for (let y = height; y >= 0; y--) {\n    let row: number[] = [];\n    for (let x = 0; x <= width; x++) {\n      let boardNode;\n      for (let snake of gameState.board.snakes) {\n        for (let snakePart of snake.body) {\n          if (snakePart.x === x && snakePart.y === y ||\n            snake.head.x === x && snake.head.y === y) {\n            boardNode = 1;\n            break;\n          } else {\n            boardNode = 0;\n          }\n        }\n        break;\n      }\n      row.push(boardNode);\n    }\n    array.push(row);\n  }\n  return array;\n}\n\nfunction getClosestFood(gameState: GameState): Coord[] {\n  let foodArray: Coord[] = gameState.board.food;\n  const head = gameState.you.head;\n  let query: Coord[] = [];\n\n  for (let f = 0; f < foodArray.length; f++) {\n    var closest = foodArray.reduce((prev, curr): Coord => {\n      if (Math.abs(curr.x - head.x) < Math.abs(prev.x - head.x) === true &&\n        Math.abs(curr.y - head.y) < Math.abs(prev.y - head.y) === true) {\n\n        //console.log(\"-----CURR-----\")\n        //console.log(curr)\n        //console.log(\"PREV\")\n        //console.log(prev)\n\n        return curr;\n      } else {\n\n        //console.log(\"-----PREV-----\")\n        //console.log(prev)\n        //console.log(\"CURR\")\n        //console.log(curr)\n\n        return prev;\n      }\n    });\n\n    //console.log(\"--CLOSEST INSIDE--\")\n    //console.log(closest)\n\n    //if (query.find((coord) => coord.x === closest.x && coord.y === closest.y) === undefined) {\n    query.push(closest);\n    //}\n\n    let a = foodArray.find((food) => { return food.x === closest.x && food.y === closest.y; })\n\n    //console.log(\"AAAA\")\n    //console.log(a)\n\n    foodArray.splice(foodArray.indexOf(a), 1)\n  }\n\n  console.log(\"--HEAD LOCATION--\")\n  console.log(`x: ${gameState.you.head.x}, y: ${gameState.you.head.y}`)\n  console.log(\"--FOOD IN BOARD--\")\n  console.log(gameState.board.food)\n  console.log(\"--FOOD ARRAY LENGTH--\")\n  console.log(gameState.board.food.length)\n  console.log(\"--QUERY--\")\n  console.log(query)\n\n  return query;\n}\n\nfunction translateCoordsToDirections(gameState: GameState, coordArray: number[][]): string[] {\n  const directions = { up: 'up', down: 'down', left: 'left', right: 'right' };\n  let translatedArray: string[] = [];\n  let xRef = gameState.you.head.x;\n  let yRef = gameState.you.head.y;\n\n  const wallDetection = gameState.you.head.x >= 0 &&\n    gameState.you.head.x < gameState.board.width - 1 &&\n    gameState.you.head.y >= 0 &&\n    gameState.you.head.y < gameState.board.height - 1;\n\n  console.log(\"b4 for loop t\")\n  for (let coordIndex = 0; coordIndex < coordArray.length; coordIndex++) {\n    let coord = coordArray[coordIndex];\n    console.log(translatedArray.length)\n\n    if (coord[0] < xRef && wallDetection) {\n      console.log(\"left\")\n      translatedArray.push(directions.left);\n    }\n    else if (coord[0] > xRef && wallDetection) {\n      console.log(\"right\")\n      translatedArray.push(directions.right);\n    }\n    else if (coord[1] > yRef && wallDetection) {\n      console.log(\"up\")\n      translatedArray.push(directions.up);\n    }\n    else if (coord[1] < yRef && wallDetection) {\n      console.log(\"down\")\n      translatedArray.push(directions.down);\n    }\n    else {\n      //throw new Error('Error, the snake tried to move in an unorthodox manner.');\n    }\n\n    xRef = coord[0];\n    yRef = coord[1];\n  }\n\n  console.log(\"--- T ARRAYYYYYYY INSIDE--\")\n  console.log(translatedArray)\n  return translatedArray;\n}\n\nfunction createTranslatedArray(gameState: GameState, aStarInstance: AStarFinder): string[] {\n  const foodBoard = getClosestFood(gameState);\n\n  console.log(\"--CLOSEST F--\")\n  console.log(foodBoard)\n\n  let astartranslatedpath: string[] = [];\n\n  var startTime = performance.now()\n  let help = aStarInstance.findPath(gameState.you.head, foodBoard[0]);\n  var endTime = performance.now()\n  console.log(`Call to HELP F took ${endTime - startTime} milliseconds`)\n\n  console.log(\"--HELP F--\")\n  console.log(help)\n\n  //help.shift();\n  //help.map((pathfindingCoord) => {\n  //  astartranslatedpath.push(translateCoordToDirection(gameState, pathfindingCoord))\n  //});\n  return translateCoordsToDirections(gameState, help);\n}\n\n// Snake metadata\nfunction info(): InfoResponse {\n  console.log(\"INFO\");\n\n  return {\n    apiversion: \"1\",\n    author: \"Caraxes\",\n    color: \"#800000\",\n    head: \"evil\",\n    tail: \"hook\",\n  };\n}\n\n// start is called when your Battlesnake begins a game\nfunction start(gameState: GameState): void {\n  console.log(\"GAME START\");\n}\n\n// end is called when your Battlesnake finishes a game\nfunction end(gameState: GameState): void {\n  console.log(\"GAME OVER\\n\");\n}\n\n// move is called on every turn and returns your next move\n// Valid moves are \"up\", \"down\", \"left\", or \"right\"\n// See https://docs.battlesnake.com/api/example-move for available data\nfunction move(gameState: GameState): MoveResponse {\n\n  // A* instance (pathfinder)\n  let aStarInstance: AStarFinder;\n  let arrayRepresentation: number[][] = createArrayRepresentation(gameState);\n  aStarInstance = new AStarFinder({\n    grid: {\n      matrix: arrayRepresentation\n    },\n    diagonalAllowed: false,\n    includeStartNode: false,\n    weight: 0,\n  });\n  let astartranslatedpath = createTranslatedArray(gameState, aStarInstance)\n\n  // Head and neck references\n  const myHead = gameState.you.body[0];\n  const myNeck = gameState.you.body[1];\n\n  // CAUTION I made it so this is 0-indexed (just so it's easier to correlate data structures and stuff)\n  const boardWidth = gameState.board.width - 1;\n  const boardHeight = gameState.board.height - 1;\n\n  let isMoveSafe: { [key: string]: boolean; } = {\n    up: true,\n    down: true,\n    left: true,\n    right: true\n  };\n\n  // DON'T GO BACKWARDS\n  if (myNeck.x < myHead.x) {\n    // Neck is left of head, don't move left\n    isMoveSafe.left = false;\n  } else if (myNeck.x > myHead.x) {\n    // Neck is right of head, don't move right\n    isMoveSafe.right = false;\n  } else if (myNeck.y < myHead.y) {\n    // Neck is below head, don't move down\n    isMoveSafe.down = false;\n  } else if (myNeck.y > myHead.y) {\n    // Neck is above head, don't move up\n    isMoveSafe.up = false;\n  }\n\n  // DON'T MOVE OUT OF BOUNDS\n  if (isMoveSafe.left || isMoveSafe.right) {\n    switch (myHead.x) {\n      case 0: {\n        isMoveSafe.left = false;\n        break;\n      }\n      case boardWidth: {\n        isMoveSafe.right = false;\n        break;\n      }\n    }\n  }\n\n  if (isMoveSafe.down || isMoveSafe.up) {\n    switch (myHead.y) {\n      case 0: {\n        isMoveSafe.down = false;\n        break;\n      }\n      case boardHeight: {\n        isMoveSafe.up = false;\n        break;\n      }\n    }\n  }\n  // -------------------------hers\n  // DON'T COLLIDE WITH BODY\n  const containsCoordExcludingTail = (snake: Coord[], coord: Coord) => {\n    const tail = snake[snake.length - 1];\n    for (var c of snake) {\n      if (c.x === coord.x && c.y === coord.y && (c.x !== tail.x || c.y !== tail.y)) return true;\n    }\n    return false;\n  }\n\n  let myBody = gameState.you.body;\n  const leftMove = { x: myHead.x - 1, y: myHead.y };\n  const rightMove = { x: myHead.x + 1, y: myHead.y };\n  const upMove = { x: myHead.x, y: myHead.y + 1 };\n  const downMove = { x: myHead.x, y: myHead.y - 1 };\n\n  if (isMoveSafe.down && containsCoordExcludingTail(myBody, downMove)) isMoveSafe.down = false;\n  if (isMoveSafe.up && containsCoordExcludingTail(myBody, upMove)) isMoveSafe.up = false;\n  if (isMoveSafe.left && containsCoordExcludingTail(myBody, leftMove)) isMoveSafe.left = false;\n  if (isMoveSafe.right && containsCoordExcludingTail(myBody, rightMove)) isMoveSafe.right = false;\n\n\n  // DON'T COLLIDE WITH OTHER SNAKES\n  const opponents = gameState.board.snakes;\n  opponents.forEach((opponent: Battlesnake) => {\n    const opponentBody = opponent.body;\n    if (isMoveSafe.down && containsCoordExcludingTail(opponentBody, downMove)) isMoveSafe.down = false;\n    if (isMoveSafe.up && containsCoordExcludingTail(opponentBody, upMove)) isMoveSafe.up = false;\n    if (isMoveSafe.left && containsCoordExcludingTail(opponentBody, leftMove)) isMoveSafe.left = false;\n    if (isMoveSafe.right && containsCoordExcludingTail(opponentBody, rightMove)) isMoveSafe.right = false;\n  })\n\n  // Are there any safe moves left?\n  const safeMoves = Object.keys(isMoveSafe).filter(key => isMoveSafe[key]);\n  if (safeMoves.length == 0) {\n    console.log(`MOVE ${gameState.turn}: No safe moves detected! Moving down`);\n    return { move: \"down\" };\n  }\n\n  // Choose a random move from the safe moves\n  const nextMove = safeMoves[Math.floor(Math.random() * safeMoves.length)];\n\n  //let foodBoard = getClosestFood(gameState);\n  // the snake currently just follows the nearest food source, it's NOT using safeMoves implementation (but it's flexible, so we should be able to adapt just fine)\n  //let astartranslatedpath = createTranslatedArray(gameState, aStarInstance)\n  console.log(\"-- T PATH --\")\n  console.log(astartranslatedpath)\n  //let help = aStarInstance.findPath(gameState.you.head, foodBoard[0]);\n  //help.shift();\n  //help.map((pathfindingCoord) => {\n  //  astartranslatedpath.push(translateCoordToDirection(gameState, pathfindingCoord))\n  //});\n  console.log(\"TURN \" + gameState.turn + \" ++++++++++++++++++++++++++++++\")\n\n  let movevar = astartranslatedpath[0];\n\n  console.log(\"MOVEVAR\")\n  console.log(movevar)\n\n  return { move: movevar };\n}\n\nrunServer({\n  info: info,\n  start: start,\n  move: move,\n  end: end\n});\n\n// TODO: Step 2 - Prevent your Battlesnake from colliding with itself\n// let myBody = gameState.you.body;\n\n// TODO: Step 3 - Prevent your Battlesnake from colliding with other Battlesnakes\n// opponents = gameState.board.snakes;\n\n// TODO: Step 4 - Move towards food instead of random, to regain health and survive longer\n// food = gameState.board.food;"],
  "mappings": "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",
  "names": []
}
