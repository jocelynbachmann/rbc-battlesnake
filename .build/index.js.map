{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["// Welcome to\n// __________         __    __  .__                               __\n// \\______   \\_____ _/  |__/  |_|  |   ____   ______ ____ _____  |  | __ ____\n//  |    |  _/\\__  \\\\   __\\   __\\  | _/ __ \\ /  ___//    \\\\__  \\ |  |/ // __ \\\n//  |    |   \\ / __ \\|  |  |  | |  |_\\  ___/ \\___ \\|   |  \\/ __ \\|    <\\  ___/\n//  |________/(______/__|  |__| |____/\\_____>______>___|__(______/__|__\\\\_____>\n//\n// This file can be a nice home for your Battlesnake logic and helper functions.\n//\n// To get you started we've included code to prevent your Battlesnake from moving backwards.\n// For more info see docs.battlesnake.com\n\n// info is called when you create your Battlesnake on play.battlesnake.com\n// and controls your Battlesnake's appearance\n// TIP: If you open your Battlesnake URL in a browser you should see this data\n\nimport runServer from './server';\nimport { GameState, InfoResponse, MoveResponse, Coord, CoordNode, Board } from './types';\nimport { AStarFinder } from \"astar-typescript\";\n\nfunction createArrayRepresentation(gameState: GameState): number[][] {\n  let array: number[][] = [];\n  const width = gameState.board.width - 1; //10\n  const height = gameState.board.height - 1; //10\n  for (let y = height; y >= 0; y--) {\n    let row: number[] = [];\n    for (let x = 0; x <= width; x++) {\n      let boardNode;\n      for (let snake of gameState.board.snakes) {\n        for (let snakePart of snake.body) {\n          if (snakePart.x === x && snakePart.y === y ||\n            snake.head.x === x && snake.head.y === y) {\n            boardNode = 1;\n            break;\n          } else {\n            boardNode = 0;\n          }\n        }\n        break;\n      }\n      row.push(boardNode);\n    }\n    array.push(row);\n  }\n  return array;\n}\n\nfunction getClosestFood(gameState: GameState): Coord[] {\n  let foodArray: Coord[] = gameState.board.food;\n  const head = gameState.you.head;\n  let query: Coord[] = [];\n  for (let f = 0; f < foodArray.length; f++) {\n\n    // returns closest food (on the specified array) to head\n    var closest = foodArray.reduce((prev, curr): Coord => {\n      if (Math.abs(curr.x - head.x) < Math.abs(prev.x - head.x) === true &&\n        Math.abs(curr.y - head.y) < Math.abs(prev.y - head.y) === true) {\n        return curr;\n      } else {\n        return prev;\n      }\n      //const xResult = Math.abs(curr.x - head.x) < Math.abs(prev.x - head.x) ? curr : prev;\n      //const yResult = Math.abs(curr.y - head.y) < Math.abs(prev.y - head.y) ? curr : prev;\n      //return (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev);\n    });\n\n    // If not already in the query, add it\n    if (query.find((coord) => coord.x === closest.x && coord.y === closest.y) === undefined) {\n      query.push(closest);\n    }\n\n    let a = foodArray.find((food) => { return food.x === closest.x && food.y === closest.y; })\n    if (a !== undefined) {\n      foodArray.splice(foodArray.indexOf(a), 1)\n    }\n  }\n  return query;\n}\n\nfunction translateCoordToDirection(gameState: GameState, coord: number[]): string {\n  const directions = { up: 'up', down: 'down', left: 'left', right: 'right' };\n  if (coord[0] < gameState.you.head.x) {\n    return directions.left;\n  }\n  else if (coord[0] > gameState.you.head.x) {\n    return directions.right;\n  }\n  else if (coord[1] > gameState.you.head.y) {\n    return directions.up;\n  }\n  else if (coord[1] < gameState.you.head.y) {\n    return directions.down;\n  }\n  else {\n    throw new Error('Error, the snake tried to move in an unorthodox manner.');\n  }\n}\n\n// Snake metadata\nfunction info(): InfoResponse {\n  console.log(\"INFO\");\n\n  return {\n    apiversion: \"1\",\n    author: \"\",       // TODO: Your Battlesnake Username\n    color: \"#888888\", // TODO: Choose color\n    head: \"default\",  // TODO: Choose head\n    tail: \"default\",  // TODO: Choose tail\n  };\n}\n\n// start is called when your Battlesnake begins a game\nfunction start(gameState: GameState): void {\n  console.log(\"GAME START\");\n}\n\n// end is called when your Battlesnake finishes a game\nfunction end(gameState: GameState): void {\n  console.log(\"GAME OVER\\n\");\n}\n\n// move is called on every turn and returns your next move\n// Valid moves are \"up\", \"down\", \"left\", or \"right\"\n// See https://docs.battlesnake.com/api/example-move for available data\nfunction move(gameState: GameState): MoveResponse {\n\n  // A* instance (pathfinder)\n  let aStarInstance: AStarFinder;\n  let arrayRepresentation: number[][] = createArrayRepresentation(gameState);\n  aStarInstance = new AStarFinder({\n    grid: {\n      matrix: arrayRepresentation\n    },\n    diagonalAllowed: false\n  });\n\n  // Head and neck references\n  const myHead = gameState.you.body[0];\n  const myNeck = gameState.you.body[1];\n\n  // CAUTION I made it so this is 0-indexed (just so it's easier to correlate data structures and stuff)\n  const boardWidth = gameState.board.width - 1;\n  const boardHeight = gameState.board.height - 1;\n\n  let foodBoard = getClosestFood(gameState);\n\n  let isMoveSafe: { [key: string]: boolean; } = {\n    up: true,\n    down: true,\n    left: true,\n    right: true\n  };\n\n  // Logic for not turning into itself\n  if (myNeck.x < myHead.x) {\n\n    // Neck is left of head, don't move left\n    isMoveSafe.left = false;\n  }\n  else if (myNeck.x > myHead.x) {\n\n    // Neck is right of head, don't move right\n    isMoveSafe.right = false;\n  }\n  else if (myNeck.y < myHead.y) {\n\n    // Neck is below head, don't move down\n    isMoveSafe.down = false;\n  }\n  else if (myNeck.y > myHead.y) {\n\n    // Neck is above head, don't move up\n    isMoveSafe.up = false;\n  }\n\n  // Logic that keeps it from moving out of bounds\n  switch (myHead.x) {\n\n    // If x is 0, head is on the left side of the board\n    case 0: {\n      isMoveSafe.left = false;\n      break;\n    }\n\n    // If x is 10, head is on the r side of the board\n    case boardWidth: {\n      isMoveSafe.right = false;\n      break;\n    }\n  }\n  switch (myHead.y) {\n\n    // If y is 0, head is on the bottom of the board\n    case 0: {\n      isMoveSafe.down = false;\n      break;\n    }\n\n    // If y is 10, head is on the top of the board\n    case boardHeight: {\n      isMoveSafe.up = false;\n      break;\n    }\n  }\n\n  // Are there any safe moves left?\n  const safeMoves = Object.keys(isMoveSafe).filter(key => isMoveSafe[key]);\n\n  // Choose a random move from the safe moves\n  const nextMove = safeMoves[Math.floor(Math.random() * safeMoves.length)];\n\n  // the snake currently just follows the nearest food source, it's NOT using safeMoves implementation (but it's flexible, so we should be able to adapt just fine)\n  let astartranslatedpath: string[] = [];\n  let help = aStarInstance.findPath(gameState.you.head, foodBoard[0]);\n  help.shift();\n  help.map((pathfindingCoord) => {\n    astartranslatedpath.push(translateCoordToDirection(gameState, pathfindingCoord))\n  });\n  return { move: astartranslatedpath[0] };\n}\n\nrunServer({\n  info: info,\n  start: start,\n  move: move,\n  end: end\n});\n\n// TODO: Step 2 - Prevent your Battlesnake from colliding with itself\n// let myBody = gameState.you.body;\n\n// TODO: Step 3 - Prevent your Battlesnake from colliding with other Battlesnakes\n// opponents = gameState.board.snakes;\n\n// TODO: Step 4 - Move towards food instead of random, to regain health and survive longer\n// food = gameState.board.food;"],
  "mappings": "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",
  "names": []
}
